# 1.1 자바스크립트의 동등 비교

## 1.1.1 자바스크립트의 데이터 타입
자바스크립트의 모든 값은 데이터 타입을 갖고 있으며 이는 크게 원시 타입과 객체 타입으로 구분된다.
* 원시 타입(boolean, null, undefined, number, string, symbol, bigint)
* 객체 타입(object)

>원시타입

JS에서 원시 타입이란 객체가 아닌 모든 타입을 의미한다.<br/>
또한, 원시 타입은 객체가 아니기 때문에 메서드를 갖지 않는다.

1. undefined
    * 선언한 후 값을 할당하지 않은 변수 또는 주어지지 않은 인수에 자동으로 할당되는 값이다.
    * undefined 타입은 오직 undefined라는 값만을 가질 수 있다.
2. null
    * 아직 값이 없거나 비어 있는 값이다.
    * typeof로 null을 확인하면 object라는 결과가 반환된다.<br/>(이후 변경 시도가 있었지만 호환성 문제로 인해 변경하지 못했다.)
    * undefined는 '선언됐지만 할당되지 않은 값', null은 '명시적으로 비어있음을 나타내는 값' 이다.
3. boolean
    * 참(true) 거짓(false)만을 가질 수 있는 타입이다.
    * boolean값 이외에도 조건문에서 true와 false처럼 취급되는 truthy, falsy 값이 존재한다.<br/>
    (객체와 배열은 내부에 값이 존재하는 여부와 상관없이 truthy로 취급된다.)
4. number
    * -(2^35-1)과 2^53-1 사이의 값을 저장할 수 있는 숫자형 타입이다.
    * 다른 언어와는 다르게 정수, 실수를 구분해 저장하지 않는다.
5. bigint
    * 2^53-1 이상의 값을 저장할 수 있는 숫자형 타입이다.
6. string
    * 텍스트 타입 데이터를 저장할 수 있는 타입이다.
    * 작은 따움표(')나 큰 따움표(") 또는 백틱(`)으로 표현할 수 있다.
    * 백틱(`)을 사용한 문자열은 줄바꿈이 가능하고 문자열 내부에 표현식을 쓸 수 있다는 차이점이 있다.
    * 자바스크립트에서 문자열은 원시타입이며 변경이 불가능하다.<br/>
    즉, 한번 문자열이 생성되면 해당 문자열은 변경할 수 없다.

7. Symbol
    * ES6에서 새롭게 추가된 7번째 타입이다.
    * 중복되지 않는 고유한 값을 나타내기 위해 만들어졌다.
    * 심벌은 심벌 함수만을 이용해서 만들 수 있다.

>객체타입

원시 타입 이외의 모든 것은 객체 타입이다.<br/>
객체 타입에는 배열, 함수, 정규식, 클래스 등이 포함된다.<br/>
객체 타입은 참조를 전달한다고 해서 참조 타입으로도 불리며 이 때, 자바스크립트의 동등 비교의 특징이 나타난다.

<br/>

## 1.1.2 값을 저장하는 방식의 차이

원시 타입과 객체 타입의 가장 큰 차이점은 '값을 저장하는 방식'이다.

원시 타입은 불변 형태의 값으로 저장된다.<br/>
그리고 이 값은 변수 할당 시점에 메모리 영역을 차지하고 저장된다.<br/>
반면 객체는 변경 가능한 형태로 저장된다.<br/>
또한 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.

즉, 객체는 값을 저장하는 것이 아니라 참조를 저장하기 때문에 서로 다른 객체의 내부 데이터가 동일한 값이더라고 각 객체는 다른 참조를 바라보기 때문에 동등 비교 시 false를 반환한다.

따라서 자바스크립트에서 객체 간의 비교가 발생한다면 이 객체 간의 비교는 내부의 값이 같다 하더라도 결과는 true가 아닐 수 있다는 것을 인지해야한다.

<br/>

## 1.1.3 자바스크립트의 또 다른 비교 공식

자바스크립트에서는 비교를 위해 Object.is를 제공한다.
Object.is는 두 개의 인수를 받으며 두 인수가 동일한지 확인하고 반환하는 메서드이다.

Object.is과 ==, ===의 차이점은 아래와 같다.
* '==' 는 비교하기 전에 양쪽이 같은 타입이 아니라면 강제로 형변환 후 비교를 수행한다.
```javascript
5 == '5' // true
Object.is(5, '5') // false
/** 
 * [ == ]
 * 좌측 5를 '5'로 강제 형변환 하여 비교를 수행한다.
 * 따라서 '5' == '5' 이므로 true를 반환한다.
 * [ Object.is() ]
 * 강제 형변환 없이 비교를 수행한다.
 * 따라서 5 == '5' 이므로 flase를 반환한다.
 * */ 
```
* '===' 보다 'Object.is'가 조금 더 정확히 비교한다.

하지만 여전히 객체 간 비교에 있어서는 Object.is, ==, === 모두 부적합하다.

<br/>

## 1.1.4 리액트에서의 동등 비교

리액트에서는 동등 비교가 어떻게 이루어질까?<br/>
리액트에서 사용하는 동등 비교 방식은 Object.is이다.<br/>
하지만 Object.is는 ES6에서 제공하는 기능이기 때문에 리액트에서는 폴리필을 함께 사용한다.

리액트는 Object.is를 기반으로 동등 비교를 하는 shallowEqual 함수를 만들어 의존성 비교 등 리액트의 동등 비교가 필요한 다양한 곳에서 사용한다.<br/>
이 때, shallowEqual은 객체의 얕은 비교를 수행한다.<br/>
즉, 객체의 첫 번째 깊이에 존재하는 값만 비교를 수행한다.

리액트에서는 Objcet.is로 먼저 비교를 수행한 다음 Object.is에서 수행하지 못하는 비교는 shallowEqual을 통해 객체 간 얕은 비교를 한 번 더 수행한다.

리액트에서 객체의 얕은 비교까지만 구현한 이유는 JSX props만 일차적으로 비교하면 되기 때문이다.<br/>
기본적으로 리액트는 props에서 꺼내온 값을 기준으로 렌더링을 수행하기 때문에 일반적인 케이스에서는 얕은 비교로 충분할 것이다.<br/>
하지만 props에 또 다른 객체를 넘겨준다면 리액트 렌더링이 예상치 못하게 작동한다는 것을 알 수 있다.

만약 리액트에서 props 객체 내부에 있는 객체까지 완벽하게 비교하기 위해 재귀문까지 넣었다면 내부에 객체의 깊이가 몇 개까지 있을 지 알 수 없어 오히려 성능에 악영향을 미쳤을 것이다.