# 1.1 자바스크립트의 동등 비교

## 1.1.1 자바스크립트의 데이터 타입
자바스크립트의 모든 값은 데이터 타입을 갖고 있으며 이는 크게 원시 타입과 객체 타입으로 구분된다.
* 원시 타입(boolean, null, undefined, number, string, symbol, bigint)
* 객체 타입(object)

>원시타입

JS에서 원시 타입이란 객체가 아닌 모든 타입을 의미한다.<br/>
또한, 원시 타입은 객체가 아니기 때문에 메서드를 갖지 않는다.

1. undefined
    * 선언한 후 값을 할당하지 않은 변수 또는 주어지지 않은 인수에 자동으로 할당되는 값이다.
    * undefined 타입은 오직 undefined라는 값만을 가질 수 있다.
2. null
    * 아직 값이 없거나 비어 있는 값이다.
    * typeof로 null을 확인하면 object라는 결과가 반환된다.<br/>(이후 변경 시도가 있었지만 호환성 문제로 인해 변경하지 못했다.)
    * undefined는 '선언됐지만 할당되지 않은 값', null은 '명시적으로 비어있음을 나타내는 값' 이다.
3. boolean
    * 참(true) 거짓(false)만을 가질 수 있는 타입이다.
    * boolean값 이외에도 조건문에서 true와 false처럼 취급되는 truthy, falsy 값이 존재한다.<br/>
    (객체와 배열은 내부에 값이 존재하는 여부와 상관없이 truthy로 취급된다.)
4. number
    * -(2^35-1)과 2^53-1 사이의 값을 저장할 수 있는 숫자형 타입이다.
    * 다른 언어와는 다르게 정수, 실수를 구분해 저장하지 않는다.
5. bigint
    * 2^53-1 이상의 값을 저장할 수 있는 숫자형 타입이다.
6. string
    * 텍스트 타입 데이터를 저장할 수 있는 타입이다.
    * 작은 따움표(')나 큰 따움표(") 또는 백틱(`)으로 표현할 수 있다.
    * 백틱(`)을 사용한 문자열은 줄바꿈이 가능하고 문자열 내부에 표현식을 쓸 수 있다는 차이점이 있다.
    * 자바스크립트에서 문자열은 원시타입이며 변경이 불가능하다.<br/>
    즉, 한번 문자열이 생성되면 해당 문자열은 변경할 수 없다.

7. Symbol
    * ES6에서 새롭게 추가된 7번째 타입이다.
    * 중복되지 않는 고유한 값을 나타내기 위해 만들어졌다.
    * 심벌은 심벌 함수만을 이용해서 만들 수 있다.

>객체타입

원시 타입 이외의 모든 것은 객체 타입이다.<br/>
객체 타입에는 배열, 함수, 정규식, 클래스 등이 포함된다.<br/>
객체 타입은 참조를 전달한다고 해서 참조 타입으로도 불리며 이 때, 자바스크립트의 동등 비교의 특징이 나타난다.

<br/>

## 1.1.2 값을 저장하는 방식의 차이

원시 타입과 객체 타입의 가장 큰 차이점은 '값을 저장하는 방식'이다.

원시 타입은 불변 형태의 값으로 저장된다.<br/>
그리고 이 값은 변수 할당 시점에 메모리 영역을 차지하고 저장된다.<br/>
반면 객체는 변경 가능한 형태로 저장된다.<br/>
또한 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.

즉, 객체는 값을 저장하는 것이 아니라 참조를 저장하기 때문에 서로 다른 객체의 내부 데이터가 동일한 값이더라고 각 객체는 다른 참조를 바라보기 때문에 동등 비교 시 false를 반환한다.

따라서 자바스크립트에서 객체 간의 비교가 발생한다면 이 객체 간의 비교는 내부의 값이 같다 하더라도 결과는 true가 아닐 수 있다는 것을 인지해야한다.

<br/>

## 1.1.3 자바스크립트의 또 다른 비교 공식

자바스크립트에서는 비교를 위해 Object.is를 제공한다.
Object.is는 두 개의 인수를 받으며 두 인수가 동일한지 확인하고 반환하는 메서드이다.

Object.is과 ==, ===의 차이점은 아래와 같다.
* '==' 는 비교하기 전에 양쪽이 같은 타입이 아니라면 강제로 형변환 후 비교를 수행한다.
```javascript
5 == '5' // true
Object.is(5, '5') // false
/** 
 * [ == ]
 * 좌측 5를 '5'로 강제 형변환 하여 비교를 수행한다.
 * 따라서 '5' == '5' 이므로 true를 반환한다.
 * [ Object.is() ]
 * 강제 형변환 없이 비교를 수행한다.
 * 따라서 5 == '5' 이므로 flase를 반환한다.
 * */ 
```
* '===' 보다 'Object.is'가 조금 더 정확히 비교한다.

하지만 여전히 객체 간 비교에 있어서는 Object.is, ==, === 모두 부적합하다.

<br/>

## 1.1.4 리액트에서의 동등 비교

리액트에서는 동등 비교가 어떻게 이루어질까?<br/>
리액트에서 사용하는 동등 비교 방식은 Object.is이다.<br/>
하지만 Object.is는 ES6에서 제공하는 기능이기 때문에 리액트에서는 폴리필을 함께 사용한다.

리액트는 Object.is를 기반으로 동등 비교를 하는 shallowEqual 함수를 만들어 의존성 비교 등 리액트의 동등 비교가 필요한 다양한 곳에서 사용한다.<br/>
이 때, shallowEqual은 객체의 얕은 비교를 수행한다.<br/>
즉, 객체의 첫 번째 깊이에 존재하는 값만 비교를 수행한다.

리액트에서는 Objcet.is로 먼저 비교를 수행한 다음 Object.is에서 수행하지 못하는 비교는 shallowEqual을 통해 객체 간 얕은 비교를 한 번 더 수행한다.

리액트에서 객체의 얕은 비교까지만 구현한 이유는 JSX props만 일차적으로 비교하면 되기 때문이다.<br/>
기본적으로 리액트는 props에서 꺼내온 값을 기준으로 렌더링을 수행하기 때문에 일반적인 케이스에서는 얕은 비교로 충분할 것이다.<br/>
하지만 props에 또 다른 객체를 넘겨준다면 리액트 렌더링이 예상치 못하게 작동한다는 것을 알 수 있다.

만약 리액트에서 props 객체 내부에 있는 객체까지 완벽하게 비교하기 위해 재귀문까지 넣었다면 내부에 객체의 깊이가 몇 개까지 있을 지 알 수 없어 오히려 성능에 악영향을 미쳤을 것이다.

<br/>
<br/>

# 1.2 함수

## 1.2.1 함수란 무엇인가?

자바스크립트에서 함수란 작업을 수행하거나 값을 계산하는 등의 과정을 하나의 블록으로 감싸 실행 단위로 만들어 놓은 것이다.<br/>
함수는 함수명, 매개변수, 반환값으로 구성되어 있다.

리액트에서 컴포넌트를 만드는 함수도 이러한 기초적인 형태를 따르는 것을 알 수 있다.<br/>
아래 컴포넌트를 함수의 관점으로 살펴보자.<br/>
**함수명**이 **Component**이고 **props**라는 **매개변수**를 받아 **반환값**으로 **JSX**를 반환하는 함수이다.

```javascript
function Component(props) {
    return <div>{props.hello}</div>
}
```
<br/>

## 1.2.2 함수를 정의하는 4가지 방법

>기반 지식
* 표현식이란 어떠한 값을 산출하는 구문을 의미한다.
* 일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미한다.
* 함수는 일급 객체이다.
* 호이스팅이란 함수에 대한 선언을 실행 전 미리 메모리에 함수를 등록하는 작업을 의미한다.
* this란 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값이다.

<br/>

> 함수 선언문

* 함수 선언문은 표현식이 아닌 일반문으로 분류된다.

```javascript
function add(a, b){
    return a + b;
}
```

<br/>

> 함수 표현식

* 함수는 일급 객체이므로 변수에 할당할 수 있다.
* 함수 선언식과 함수 표현식의 가장 큰 차이점은 호이스팅 여부이다.
* 함수 선언식은 호이스팅이 발생하지만 함수 표현식은 호이스팅이 발생하지 않는다.

```javascript
const add = function(a, b) {
    return a + b;
}
```

<br/>

> Function 생성자

* Function 생성자 함수를 사용한 함수 생성은 매개변수와 함수의 몸통을 모두 문자열로 작성해야하기 때문에 코드 작성 관점에서 나쁘다.
* Function 생성자 함수 방식은 함수의 클로저가 생성되지 않는다.

```javascript
const add = new Function('a', 'b', 'return a + b' );
```

<br/>

> 화살표 함수
* ES6에서 새롭게 추가된 함수 생성 방식이다.
* 화살표 함수에서는 constructor를 사용할 수 없다.
* 화살표 함수에서는 argument가 없다.
* 화살표 함수는 함수 자체의 바인딩을 갖지 않아 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따르게 된다.
* 화살표 함수의 this는 선언되는 시점에 결정되며 일반 함수는 함수가 호출되는 런타임 시점에 결정된다.

```javascript
const add = (a, b) => {
    return a + b;
}
```

<br/>

## 1.2.3 함수를 정의하는 4가지 방법

> 즉시 실행 함수

* 함수를 정의하는 즉시 실행되는 함수이다.
* 한 번만 호출되며 이후 다시는 호출할 수 없다.
* 즉시 실행 함수에는 함수명을 붙이지 않는다.
* 즉시 실행 함수의 특성을 통해 글로벌 스코프를 오염시키지 않을 수 있다는 장점이 있다.

```javascript
// 즉시 실행 함수1
(function (a, b) {
    return a + b
})(10, 24);

// 즉시 실행 함수2
((a, b)=> {
    return a + b
})(10, 24);
```

<br/>

> 고차 함수
* 함수가 일급 객체라는 특징을 활용해 함수를 인수로 받거나 반환값으로 함수를 반환시키는 함수이다.
* 함수 컴포넌트를 인수로 받아 새로운 함수 컴포넌트를 반환하는 고차 함수를 만들 수도 있다.
* 고차 함수 컴포넌트를 만들면 컴포넌트 내부에서 공통으로 관리되는 로직을 분리해 관리할 수 있어 효율적인 리팩토링이 가능하다.

```javascript
// 함수를 매개변수로 받는 고차함수 예시(Array.prototype.map)
const doubleArray = [1, 2, 3].map((item)=>item * 2);
```

<br/>

## 1.2.4 함수를 만들 때 주의해야 할 사항

1. 함수의 부수 효과를 억제해야 한다.
2. 함수를 작게 만들어야 한다.
3. 이해할 수 있는 함수명을 붙여야한다.

<br/>
<br/>

# 1.3 클래스
## 1.3.1 클래스란 무엇인가?

* 자바스크립트에서 클래스란 특정한 객체를 만들기 위한 일종의 템플릿이다.
* ES6 이전에는 클래스 개념이 존재하지 않아 클래스 역할을 함수가 대신하였다.

<br/>

> constructor
* constructor는 객체를 생성하는 데 사용하는 특수한 메서드이다.
* constructor는 단 하나만 존재할 수 있다.
* constructor는 생략할 수 있다.

<br/>

> 프로퍼티
* 프로퍼티는 클래스로 인스턴스를 생성할 떄 내부에 정의할 수 있는 속성값을 의미한다.
* 인스턴스를 생성할 때 기본적으로 contructor 내부에 할당되어 있는 빈 객체에 프로터티의 키와 값을 넣어 활용할 수 있도록 한다.

<br/>

> getter
* getter는 클래스에서 어떤 값을 가져올 때 사용된다.
* getter를 사용하기 위해서는 앞에 get을 붙이고 getter의 이름을 선언해야 한다.

<br/>

```js
class Car {
    constructor(name) {
        this.name = name;
    }

    get getMyName() {
        return this.name;
    }
}
```

<br/>

> setter
* getter는 클래스 필드에 어떤 값을 할당할 때 사용된다.
* getter를 사용하기 위해서는 앞에 set을 붙이고 setter의 이름을 선언해야 한다.

<br/>

```js
class Car {
    constructor(name) {
        this.name = name;
    }

    get getMyName() {
        return this.name;
    }

    set setMyName(name) {
        this.name = name;
    }
}
```

<br/>

> 인스턴스 메서드
* 인스턴스 메서드란 클래스 내부에서 선언한 메서드를 의미한다.
* 인스턴스 메서드는 프로토타입에 선언된다.
* 인스턴스 메서드는 프로토타입 메서드라고도 불린다.
* 프로토 타입 체인을 통해 메서드를 생성된 객체(인스턴스)에 직접 선언하지 않았어도 인스턴스 메서드를 호출할 수 있다.

<br/>

> 프로토타입
* 프로토타입이란 다른 객체로부터 속성이나 메서드를 상속받을 수 있게 해주는 메커니즘이다.
* 자바스크립트에서 모든 객체는 prototype이라는 속성을 가지고 있다.

<br/>

> 프로토타입 체인
* 프로토타입 체인이란 객체가 특정 속성이나 메서드를 찾을 때, 해당 객체에 없으면 상위 프로토타입을 계속 따라가면서 찾는 상속 메커니즘이다.
* 프로토타입 체인을 통해 인스턴스가 인스턴스 메서드에 접근할 수 있다.
* Object.getPrototypeOf()를 통해 객체의 프로토타입을 확인할 수 있다.

<br/>

```js
class Person {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

const person1 = new Person('John');
person1.sayHello();  // "Hello, my name is John"

/** 
 * Person은 클래스이다.
 * person1은 Person 클래스의 인스턴스이다.
 * sayHello는 Person 클래스의 프로토타입 메서드로 정의된다.
*/

/** 
 * person1은 Person.prototype을 상속받는다.
 * Person.prototype은 Object.prototype을 상속받는다.
 * Object.prototype은 최상위 부모이다.
*/

```

<br/>

> 정적 메서드
* 정적 메서드란 클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드이다.
* 정적 메서드 내부의 this는 인스턴스가 아닌 클래스 자신을 가리킨다.

<br/>

> 상속
* 상속이란 기존 클래스를 기반으로 확장하는 개념이다.

<br/>

## 1.3.2 클래스와 함수의 관계
* 클래스에서 인스턴스 메서드가 자동으로 프로토타입에 선언되는 것은 함수에서 프로토타입에 함수를 직접 할당하여 구현한다.
* 클래스에서 정적 메서드는 함수에서 메서드를 직접할당하여 구현한다.
* 클래스에서의 getter와 setter는 함수에서 객체에 속성을 직접 정의하여 구현한다.

<br/>
<br/>

# 1.4 클로저
## 1.4.1 클로저의 정의
* 클로저란 함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합을 의미한다.
* 어휘적 환경(Lexical Scope)이란 변수가 코드 내부 어디에서 선언되었는 지를 말한다.

<br/>

## 1.4.2 스코프
* 스코프란 변수의 유효범위를 의미한다.

<br />

> 전역 스코프
* 전역 스코프란 전역 레벨에 선언하는 것을 의미한다.
* window, global 과 같은 객체에 전역 레벨에서 선언한 스코프가 바인딩된다.

<br />

> 함수 스코프
* 자바스크립트는 기본적으로 함수 레벨 스코프를 따른다.
* 블록 레벨 스코프를 따르는 다른 언어와 차이가 있으니 유의해야 한다.

<br/>


## 1.4.3 클로저의 활용
* 전역 스코프는 어디서든 원하는 값을 꺼내올 수 있기 때문에 누구든 접근 및 수정이 가능하여 보안에 취약하다.
* 클로저를 활용해 변수의 수정 및 조작을 외부에서 불가능하도록 만들 수 있다.
* 리액트에서 useState 또한 클로저가 활용되었기 때문에 외부함수(useState)가 종료된 이후에도 내부함수(setState)가 state 를 기억할 수 있다.

<br/>
<br/>


# 1.5 이벤트 루프와 비동기 통신의 이해
* 자바스크립트는 싱글 스레드에서 작동하기 때문에 한 번에 하나의 작업만 동기 방식으로만 처리할 수 있다.
* 동기란 직렬 방식의 작업으로 요청이 시작 
* 하지만 우리는 웹 프로그래밍에서 다양한 비동기 작업을 수행하고 있는데 어떻게 가능한걸까?

<br/>

## 1.5.1 싱글 스레드 자바스크립트
* 프로세스란 프로그램이 구동되어 메모리 상에서 실행되는 작업 단위를의미한다.
* 하나의 프로그램에는 하나의 프로세스만 할당된다.
* 스레드란 프로그램의 복잡한 작업을 수행하기 위해 더 작은 실행단위이다.
* 하나의 프로세스에는 여러 개의 스레드를 만들 수 있다.
* 스레드끼리는 메모리를 공유할 수 있다.
* 자바스크립트는 싱글 스레드이다.
* 자바스크립트는 싱글 스레드이기 때문에 하나의 작업이 끝나기 전까지 뒤이은 작업이 실행되지 않는다.
* 동기식으로 작동하는 자바스크립트에서 비동기 코드를 이해하기 위해서는 이벤트루프에 대해 이해해야한다.

<br/>

## 1.5.2 이벤트 루프란?
* 이벤트루프는 자바스크립트 런타임 외부에서 비동기 실행을 돕기 위해 만들어진 장치이다.

<br/>

> 호출스택
* 호출 스택이란 수행해야 할 코드나 함수를 순차적으로 담아두는 스택이다.
* 이벤트 루프는 호출 스택이 비어 있는지 여부를 확인한다. 
* 코드 실행과 호출 스택 진공 여부 파악은 동시에 진행될 수 없으며 하나의 스레드에서 순차적으로 일어난다.

<br/>

> 태스크 큐
* 태스크 큐란 실행해야 할 태스크의 집합을 의미한다.
* 이벤트 루프는 태스크 큐를 하나 이상 가지고 있다.

<br/>

> 비동기 함수는 누가 수행하는가?
* setTimeout, fetch와 같은 작업들은 메인 스레드가 아닌 태스크 큐가 할당되는 스레드(브라우저, Node.js)에서 수행된다.
* 자바스크립트 코드 실행은 싱글 스레드에서 이루어지지만 외부 Web API(setTimeout, fetch) 등은 모두 자바스크립트 코드 외부에서 실행되며 이에 대한 콜백이 태스크 큐로 들어간다.

<br/>

## 1.5.3 태스크 큐와 마이크로 태스크 큐

<br/>

> 마이크로 태스크 큐
* 이벤트 루프는 하나의 마이크로 태스크 큐를 갖는다.
* 마이크로 태스크 큐는 일반 태스크 큐보다 우선순위를 갖는다.
* 대표적인 마이크로 태스크 큐에는 Promise가 있다.

<br/>

> 렌더링은 언제 실행될까?
* 마이크로 태스크 큐가 실행된 후에 렌더링이 일어난다.
* 즉, 각 마이크로 태스크 큐 작업이 끝날 때마다 렌더링 기회를 갖는다.

<br/>
<br/>

# 1.6 리액트에서 자주 사용하는 자바스크립트 문법
* ECMAScript란 자바스크립트 표준이다.
* 브라우저와 런타임이 항상 새로운 JS 문법을 지원하는 것은 아니기 때문에 작성하는 JS 문법이 어느 ECMAScript 버전인지 알아야한다.
* 사용자의 다양한 브라우저 환경과 최신 문법을 선호하는 개발자의 요구를 해결하기 위해 바벨이 탄생했다.
* 바벨의 트랜스파일을 통해 최신 JS 문법을 다양한 브라우저에 일관적으로 지원할 수 있다.
* 바벨 트랜스파일 코드는 ES5를 기준으로 작성됐다.

<br/>

## 1.6.1 구조 분해 할당
* 구조 분해 할당이란 배열 또는 객체의 값을 분해하여 개별 변수에 즉시 할당하는 것을 의미한다.
* 배열의 구조 분해 할당은 ES6에 등장했다.
* 객체의 구조 분해 할당은 ECMA 2018에 등장했다.

<br/>

> 배열의 구조 분해 할당

배열의 구조 분해 할당은 , 의 위치에 따라 값이 결정된다.
```js
const array = [1, 2, 3, 4, 5];
const [first, , , , fifth] = array; // 2, 3, 4 는 변수 할당이 되지 않는다.

console.log(first) // 1
console.log(fifth) // 5
```

<br/>

배열 구조 분해 할당은 기본값을 선언할 수 있다.
```js
const array1 = [1, 2]
const [a = 10, b = 10, c = 10] = array1;
// a 1
// b 2
// c 10

const array2 = [undefined, null, 0, ''] 
const [ a = 1, b = 1, c = 1, d = 1, e = 1] = array2;
// undefined일 때만 기본값을 사용한다.
// a 1
// b null
// c 0
// d ''
// e 1
```

<br/>

배열 구조 분해 할당은 특정값 이후의 값을 다시 배열로 선언할 수 있다.
전개 구문(...)을 사용하여 나머지 모든 값을 해당 변수에 배열로 넣게 된다.
```js
const array = [1, 2, 3, 4, 5];
const [first, ...rest] = array;

// first 1
// rest [2, 3, 4, 5]
```

<br/>

배열 구조 분해 할당 코드의 트랜스파일 예시
```js
// 트랜스 파일 전
const array = [1, 2, 3, 4, 5];
const [e1, e2, e3 , ...arrRest]; = array;

// 트랜스 파일 후
var array = [1, 2, 3, 4, 5]
var first = array[0],
    first = array[1],
    first = array[2],
    arrRest = array.slice(3)
```

<br/>

> 객체 구조 분해 할당

객체 구조 분해 할당은 객체에서 값을 꺼내온 뒤 할당한다.
배열 구조 할당과는 다르게 객체 구조 분해 할당은 객체 내부 이름으로 꺼내온다는 차이점이 있다.

```js
const obj = {
    a : 1,
    b : 2,
    c : 3,
    d : 4,
    e : 5,
}

const {a, b, c, ...objRest} = obj;
// a 1
// b 2
// c 3
// objRest { d : 4, e : 5}
```

<br/>

객체 구조 분해 할당 시에 새로운 이름으로 다시 할당하는 것 또한 가능하다.
```js
const obj = {
    a : 1,
    b : 2,
}

const { a : first, b : second} = obj
// first 1
// second 2
```

<br/>

객체 구조 분해 할당 또한 기본값 선언이 가능하다.
```js
const obj = {
    a : 1,
    b : 2,
}

const { a = 10, b = 10, c = 10} = object
// 마찬가지로 undefined만 기본값이 선언된다.
// a 1
// b 2
// c 10
```

<br/>

객체 구조 분해 할당 또한 전개 구문 사용이 가능하다.
```js
const obj = {
    a : 1,
    b : 1,
    c : 1,
    d : 1,
    e : 1,
}

const { a, b, ...objRest} = object
// 마찬가지로 undefined만 기본값이 선언된다.
// a 1
// b 2
// objRest { c : 1, d : 1, e : 1 }
```

<br/>

* 객체 구조 분해 할당은 트랜스파일 과정이 복잡하다.
* 객체 구조 분해 할당은 트랜스파일 시 번들링 크기가 상대적으로 크다.
* 개발 환경이 ES5를 고려해야하고 객체 구조 분해 할당을 자주 사용하지 않는다면 사용 적합성에 대해 검토해 볼 필요가 있다.
* 트랜스파일은 부담스럽지만 객체 구조 분해 할당이 필요하다면 외부 라이브러리(lodash.omit, ramda.omit) 사용을 고려하는 것도 좋다.

<br/>
<br/>

## 1.6.2 전개 구문
* 전개 구문이란 배열, 객체, 문자열과 같이 순회할 수 있는 값에 대해 전개해 간결하게 사용할 수 있는 구문이다.
* 배열 전개 구문은 ES6에 등장했다.
* 객체 전개 구문은 ECMA 2018에 등장했다.

<br/>

과거에는 배열 간 합성 시에 push(), concat(), splice() 등 메서드를 사용해야 했다.
전개 구문을 활용하면 매우 쉽게 배열을 합성할 수 있다.

```js
const arr1 = ['a', 'b'];
const arr2 = [...arr1, 'c', 'd', 'e']; // ['a', 'b', 'c', 'd', 'e'] 
```

<br/>

객체에서도 배열과 비슷하게 사용이 가능하다.
```js
const obj1 = {
    a : 1,
    b : 2,
}

const obj2= {
    c : 3,
    d : 4,
}

const obj3 = {...obj1, ...obj2}; // { a : 1, b : 2, c : 3, d : 4, }
```

<br/>

객체 전개 구문에서는 순서가 중요하다.<br/>
순서 차이로 인해 전혀 다른 객체가 생성될 수 있다.<br/>
전개 구문 이후에 값 할당이 있다면 할당한 값이 이전 전개 구문 값을 덮어쓴다.<br/>
반대의 경우에는 오히려 전개 구문이 해당 값을 덮어쓴다.
```js
const obj = {
    a : 1,
    b : 1,
    c : 1,
    d : 1,
    e : 1,
}

// {a:1, b:1, c:10, d:1, e:1}
const obj1 = {
    ...obj,
    c : 10,
}

// {c: 1, a:1, b:1, d:1, e:1}
const obj2 = {
    c : 10,
    ...obj,
}
```

<br/>

배열 전개 구문의 트랜스파일 예시
```js
// 트랜스파일 전
const arr1 = ['a', 'b'];
const arr2 = [...arr1, 'c', 'd'];

// 트랜스파일 후
var arr1 = ['a', 'b'];
var arr2 = [].concat(arr1, ['c', 'd']);
```

객체 전개 구문 할당의 경우 이전처럼 트랜스파일 과정이 복잡하여 번들링 크기가 상대적으로 크다.

<br/>
<br/>

## 1.6.3 객체 초기자
객체 초기자는 ECMAScript 2015에 도입된 기능으로 객체를 선언할 때 객체에 넣고자 하는 키와 값을 가지고 있는 변수가 있다면 해당 값을 편리하게 넣어줄 수 있는 방식이다.
객체 초기자를 사용하면 객체를 좀 더 간편하게 선언할 수 있고 트랜스파일 이후에도 큰 부담이 없다.

<br/>

객체 초기자의 트랜스파일 예시
```js
// 트랜스파일 전
const a = 1;
const b = 2;

const obj = { // 객체 초기자 사용
    a,
    b,
}

// 트랜스파일 후
var a = 1;
var b = 2;

var obj = {
    a : a,
    b : b,
}
```

<br/>
<br/>

## 1.6.4 Array 프로토타입의 메서드
* map, filter, reduce, forEach 배열 메서드는 굉장히 자주 쓰인다.
* 해당 메서드들은 기존 배열의 값을 건드리지 않고 새로운 값을 만들기 때문에 기존 값이 변경될 염려 없이 안전하게 사용할 수 있다.
* 해당 메서드들은 ES5 문법익 때문에 별도의 트랜스파일 또는 폴리필 없이도 사용할 수 있다.

<br/>

> Array.prototype.map
Array.prototype.map은 배열의 각 아이템을 순회하며 각 아이템을 콜백으로 연산한 결과로 구성된 새로운 배열을 반환한다.
```js
const arr1 = [1, 2, 3, 4, 5];
const arr2 = arr1.map((item) => item * 2);

console.log(arr1); // [1, 2, 3, 4, 5]
console.log(arr2); // [2, 4, 6, 8, 10]
```

<br/>

리액트에서는 주로 특정 배열을 기반으로 리액트 요소를 반환할 때 사용한다.
```js
const arr = [1, 2, 3, 4, 5];
const Elements = arr.map((item, index) => {
    return (
        <div key={index}>{item}</div>
    )
})
```

<br/>

> Array.prototype.filter
Array.prototype.filter는 콜백 함수를 인수로 받아 참(truthy) 조건을 만족하는 원소를 반환하는 메서드이다.

```js
const arr1 = [1, 2, 3, 4, 5];
const arr2 = arr.filter((item) => item % 2 === 0);

console.log(arr1) // [1, 2, 3, 4, 5]
console.log(arr2) // [2, 4]
```

<br/>

> Array.prototype.reduce
Array.prototype.reduce는 콜백 함수와 함께 초기값을 인수로 받아 초기값에 따라 배열, 객체 또는 그 외의 무언가를 반환할 수 있는 메서드이다.
요약하자면 콜백 함수를 실행하고 이를 초기값에 누적하여 결과를 반환한다.

```js
const arr1 = [1, 2, 3, 4, 5];
const arr2 = arr.reduce((result, item) => {
    return result + item; // 초기값의 현재값 + 현재 배열의 아이템
}, 0)
// 이 때, reduce 메서드의 두번째 인수 0은 결과를 누적할 초기값이다.
// 콜백 함수의 첫번째 인수는 앞서 선언한 초기값의 현재값이다.
// 콜백 함수의 두번째 인수는 현재 배열의 아이템이다.

console.log(arr1) // [1, 2, 3, 4, 5]
console.log(arr2) // 15
```

<br/>

> Array.prototype.forEach
Array.prototype.forEach는 콜백 함수를 받아 배열을 순회하면서 콜백 함수를 실행하는 메서드이다.<br/>
forEach는 아무런 반환값이 없이 단순히 콜백 함수를 실행한다는 사실을 유의해야한다.<br/>
forEach는 실행되는 순간 에러 발생, 프로세스 종료 상황이 아닌 이상 실행을 도중에 멈출 수 없다.<br/>
즉 break, return 무엇을 이용해도 배열 순회를 멈출 수 없다.<br/>
따라서 forEach 내부의 콜백함수는 무조건 O(n) 만큼 실행된다.

```js
const arr = [1, 2, 3];

arr.forEach((item) => console.log(item));
// >> 1
// >> 2
// >> 3
```

<br/>
<br/>

## 1.6.5 삼항 조건 연산자
삼항 조건 연산자는 JS에서 유일하게 3개의 피연산자를 취할 수 있는 문법이다.

```js
const value = 10;
const result = value % 2 === 0 ? '짝수' : '홀수';

console.log(result); // >> 짝수
```

<br/>

삼항 조건 연산자는 리액트 JSX 내부에서 조건부 렌더링을 위해 자주 사용된다.
```js
function Component({condition}) { 
    return(
        <div>{condition ? '참' : '거짓'}</div>
    )
}
```

삼항 조건 연산자의 편리함 때문에 삼항 조건 연산자를 중첩해서 사용하는 경우가 종종 발생한다.
하지만 삼항 조건 연산자를 중첨하여 사용할 경우 연산 결과를 쉽게 예측하기 어렵기 때문에 권고하지 않는다.

<br/>
<br/>


# 1.7 선택이 아닌 필수, 타입스크립트
* 타입스크립트란 기존 자바스크립트 문법에 타입을 가미한 것이다.
* 타입스크립트를 사용하면 동적 언어인 JS에서 런타임에만 타입을 체크할 수 있는 한계를 극복할 수 있어 더욱 안정적이고 잠재적인 버그를 크게 줄일 수 있다.
* 최근 런타임(Deno, Bum)들도 타입스크립트를 지원한다.
* 현업에서도 대부분 타입스크립트로 개발한다.

<br/>

## 1.7.1 타입스크립트란?
```js
function test(a, b) {
    return a / b;
}

test(5, 2) // 2.5
test("안녕", "하이") // NaN
```

위 예시코드에서 test 함수에 올바른 인수를 전달하지 않았다.<br/>
이에 개발자가 원하지 않은 결과를 만들어 낸다.<br/>
이를 자바스크립트에서 타입을 체크하여 방지할 수 있다.<br/>
그러나 모든 함수, 변수에 타입 확인 연산자 typeof를 적용해 타입체크를 하게되면 너무 번거롭고 코드 크기가 과도하게 커지는 단점이 있다.<br/>
타입스크립트는 이러한 자바스크립트의 한계를 벗어나 빌드 타임에 타입 체크를 정적으로 수행할 수 있도록 한다.<br/>
위 예시코드를 아래와 같이 간결한 타입스크립트 코드로 바꿀 수 있다.<br/>

```ts
function test(a: number, b: number) {
    return a / b;
}

// js 와는 다르게 ts에서는 아래 코드는 타입 에러를 발생시킨다.
test("안녕", "하이");  // 런타임까지 가지 않아도 빌드 시점에 에러를 확인할 수 있다.
```

<br/>
<br/>

## 1.7.2 타입스크립트 활용법

> any 대신 unknown 사용하기
TS 초보자가 자주 저지르는 실수 중 하나는 any의 남용이다.<br/>
any는 정말 불가피할 때만 사용해야 하는 타입이며 any를 사용한다는 것은 사실상 TS의 정적 타이핑의 이점을 모두 버리는 것이나 다름없다.
<br/>
불가피하게 타입을 단정할 수 없다면 unknown을 사용하는 것이 좋다.<br/>
하지만 any와는 다르게 unknown 타입의 값은 바로 사용하는 것이 불가능하다.<br/>
unknown을 사용하기 위해서는 type narrowing을 적용하여야한다. <br/>
type narrowing을 적용하면 원하는 타입일 때만 의도대로 작동하도록 할 수 있다.<br/>
이렇게 unknown을 사용하면 예상치 못한 타입을 받아들일 수 있고 any 보다 안전하게 사용할 수 있다.

```ts
// 즉시 사용 불가
function test(callback: unknown) {
    callback(); // 'callback' is of type 'unknown' 에러 발생
}
```

```ts
// type narrowing 적용 (타입 좁히기)
function test(callback: unknown) {
    if(typeof callback == 'function') {
        callback();
    }
}
```

<br/>

unknown과 반대되는 never가 있다.<br/>
never를 사용하면 어떠한 타입도 들어올 수 없다.<br/>
코드상 존재가 불가능한 타입을 나타낼 때 never가 사용된다.<br/>

```ts
// 아래 타입은 존재할 수 없는 타입이기 때문에 never가 선언된다.
type what1 = string & number;
type what2 = ('hello' | 'hi') & 'react';
```

<br/>

> 타입 가드
unknown 타입 예제에서 살펴봤듯이 type narrowing은 매우 중요하다.
이러한 type narrowing에 도움을 주는 것이 타입 가드이다.
조건문과 타입가드를 함께 사용하면 타입을 효과적으로 좁힐 수 있다.

<br/>

> 제네릭
제네릭은 함수나 클래스 내부에서 단일 타입이 아닌 다양한 타입에 대응할 수 있도록 돕는 도구이다.

```ts
function test<T>(list: T[]): [T, T] {
    return [list[0], list[1]]; // 매개변수 배열의 첫번째 요소 두번째 요소를 배열에 담아 반환
}

const [first, second] = test([1,2,3]);

// first 타입 = number
// second 타입 = number

const [first, second] = test(['a', 'b', 'c']);
// first 타입 = string
// second 타입 = string
```

T라는 제네릭을 선언해 이를 각각 배열의 요소와 반환 값의 요소로 사용했다.<br/>
제네릭 덕분에 다양한 타입을 처리할 수 있는 함수를 만들 수 있다.<br/>

리액트에서 제네릭을 사용할 수 있는 코드 중에는 useState가 있다.<br/>
useState에 제네릭으로 타입을 선언한다면 state 사용과 기본값 선언을 좀 더 명확하게 할 수 있다.
<br/>
흔히 useState() 같은 형식으로 기본값을 넘기지 않는 경우가 많은데 이럴 경우 값을 undefined로 추론해 버리는 문제가 발생한다.
<br/>
재네릭으로 기본값을 선언해 준다면 이러한 문제를 TS가 방지한다.


```ts
function Conponent() {
    const [state, setState] = useState<string>('');
    // ...
}
```

<br/>

제네릭은 하나 이상 사용할 수 있다.
```ts
function test<First, Last>(a1: First, a2: Last): [First, Last] {
    return [a1, a2];
}

const [a, b] = test<string, boolean>('hello', true);

// a string
// b boolean
```

<br/>

> 인덱스 시그니처
...추후 학습


<br/>
<br/>

## 1.7.3 타입스크립트 전환 가이드
* tsconfig.json 작성하기
* @types 모듈 설치하기
* 파일 단위로 조금씩 전환하기

