# 1.1 자바스크립트의 동등 비교

## 1.1.1 자바스크립트의 데이터 타입
자바스크립트의 모든 값은 데이터 타입을 갖고 있으며 이는 크게 원시 타입과 객체 타입으로 구분된다.
* 원시 타입(boolean, null, undefined, number, string, symbol, bigint)
* 객체 타입(object)

>원시타입

JS에서 원시 타입이란 객체가 아닌 모든 타입을 의미한다.<br/>
또한, 원시 타입은 객체가 아니기 때문에 메서드를 갖지 않는다.

1. undefined
    * 선언한 후 값을 할당하지 않은 변수 또는 주어지지 않은 인수에 자동으로 할당되는 값이다.
    * undefined 타입은 오직 undefined라는 값만을 가질 수 있다.
2. null
    * 아직 값이 없거나 비어 있는 값이다.
    * typeof로 null을 확인하면 object라는 결과가 반환된다.<br/>(이후 변경 시도가 있었지만 호환성 문제로 인해 변경하지 못했다.)
    * undefined는 '선언됐지만 할당되지 않은 값', null은 '명시적으로 비어있음을 나타내는 값' 이다.
3. boolean
    * 참(true) 거짓(false)만을 가질 수 있는 타입이다.
    * boolean값 이외에도 조건문에서 true와 false처럼 취급되는 truthy, falsy 값이 존재한다.<br/>
    (객체와 배열은 내부에 값이 존재하는 여부와 상관없이 truthy로 취급된다.)
4. number
    * -(2^35-1)과 2^53-1 사이의 값을 저장할 수 있는 숫자형 타입이다.
    * 다른 언어와는 다르게 정수, 실수를 구분해 저장하지 않는다.
5. bigint
    * 2^53-1 이상의 값을 저장할 수 있는 숫자형 타입이다.
6. string
    * 텍스트 타입 데이터를 저장할 수 있는 타입이다.
    * 작은 따움표(')나 큰 따움표(") 또는 백틱(`)으로 표현할 수 있다.
    * 백틱(`)을 사용한 문자열은 줄바꿈이 가능하고 문자열 내부에 표현식을 쓸 수 있다는 차이점이 있다.
    * 자바스크립트에서 문자열은 원시타입이며 변경이 불가능하다.<br/>
    즉, 한번 문자열이 생성되면 해당 문자열은 변경할 수 없다.

7. Symbol
    * ES6에서 새롭게 추가된 7번째 타입이다.
    * 중복되지 않는 고유한 값을 나타내기 위해 만들어졌다.
    * 심벌은 심벌 함수만을 이용해서 만들 수 있다.

>객체타입

원시 타입 이외의 모든 것은 객체 타입이다.<br/>
객체 타입에는 배열, 함수, 정규식, 클래스 등이 포함된다.<br/>
객체 타입은 참조를 전달한다고 해서 참조 타입으로도 불리며 이 때, 자바스크립트의 동등 비교의 특징이 나타난다.

<br/>

## 1.1.2 값을 저장하는 방식의 차이

원시 타입과 객체 타입의 가장 큰 차이점은 '값을 저장하는 방식'이다.

원시 타입은 불변 형태의 값으로 저장된다.<br/>
그리고 이 값은 변수 할당 시점에 메모리 영역을 차지하고 저장된다.<br/>
반면 객체는 변경 가능한 형태로 저장된다.<br/>
또한 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.

즉, 객체는 값을 저장하는 것이 아니라 참조를 저장하기 때문에 서로 다른 객체의 내부 데이터가 동일한 값이더라고 각 객체는 다른 참조를 바라보기 때문에 동등 비교 시 false를 반환한다.

따라서 자바스크립트에서 객체 간의 비교가 발생한다면 이 객체 간의 비교는 내부의 값이 같다 하더라도 결과는 true가 아닐 수 있다는 것을 인지해야한다.

<br/>

## 1.1.3 자바스크립트의 또 다른 비교 공식

자바스크립트에서는 비교를 위해 Object.is를 제공한다.
Object.is는 두 개의 인수를 받으며 두 인수가 동일한지 확인하고 반환하는 메서드이다.

Object.is과 ==, ===의 차이점은 아래와 같다.
* '==' 는 비교하기 전에 양쪽이 같은 타입이 아니라면 강제로 형변환 후 비교를 수행한다.
```javascript
5 == '5' // true
Object.is(5, '5') // false
/** 
 * [ == ]
 * 좌측 5를 '5'로 강제 형변환 하여 비교를 수행한다.
 * 따라서 '5' == '5' 이므로 true를 반환한다.
 * [ Object.is() ]
 * 강제 형변환 없이 비교를 수행한다.
 * 따라서 5 == '5' 이므로 flase를 반환한다.
 * */ 
```
* '===' 보다 'Object.is'가 조금 더 정확히 비교한다.

하지만 여전히 객체 간 비교에 있어서는 Object.is, ==, === 모두 부적합하다.

<br/>

## 1.1.4 리액트에서의 동등 비교

리액트에서는 동등 비교가 어떻게 이루어질까?<br/>
리액트에서 사용하는 동등 비교 방식은 Object.is이다.<br/>
하지만 Object.is는 ES6에서 제공하는 기능이기 때문에 리액트에서는 폴리필을 함께 사용한다.

리액트는 Object.is를 기반으로 동등 비교를 하는 shallowEqual 함수를 만들어 의존성 비교 등 리액트의 동등 비교가 필요한 다양한 곳에서 사용한다.<br/>
이 때, shallowEqual은 객체의 얕은 비교를 수행한다.<br/>
즉, 객체의 첫 번째 깊이에 존재하는 값만 비교를 수행한다.

리액트에서는 Objcet.is로 먼저 비교를 수행한 다음 Object.is에서 수행하지 못하는 비교는 shallowEqual을 통해 객체 간 얕은 비교를 한 번 더 수행한다.

리액트에서 객체의 얕은 비교까지만 구현한 이유는 JSX props만 일차적으로 비교하면 되기 때문이다.<br/>
기본적으로 리액트는 props에서 꺼내온 값을 기준으로 렌더링을 수행하기 때문에 일반적인 케이스에서는 얕은 비교로 충분할 것이다.<br/>
하지만 props에 또 다른 객체를 넘겨준다면 리액트 렌더링이 예상치 못하게 작동한다는 것을 알 수 있다.

만약 리액트에서 props 객체 내부에 있는 객체까지 완벽하게 비교하기 위해 재귀문까지 넣었다면 내부에 객체의 깊이가 몇 개까지 있을 지 알 수 없어 오히려 성능에 악영향을 미쳤을 것이다.

<br/>
<br/>

# 1.2 함수

## 1.2.1 함수란 무엇인가?

자바스크립트에서 함수란 작업을 수행하거나 값을 계산하는 등의 과정을 하나의 블록으로 감싸 실행 단위로 만들어 놓은 것이다.<br/>
함수는 함수명, 매개변수, 반환값으로 구성되어 있다.

리액트에서 컴포넌트를 만드는 함수도 이러한 기초적인 형태를 따르는 것을 알 수 있다.<br/>
아래 컴포넌트를 함수의 관점으로 살펴보자.<br/>
**함수명**이 **Component**이고 **props**라는 **매개변수**를 받아 **반환값**으로 **JSX**를 반환하는 함수이다.

```javascript
function Component(props) {
    return <div>{props.hello}</div>
}
```
<br/>

## 1.2.2 함수를 정의하는 4가지 방법

>기반 지식
* 표현식이란 어떠한 값을 산출하는 구문을 의미한다.
* 일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미한다.
* 함수는 일급 객체이다.
* 호이스팅이란 함수에 대한 선언을 실행 전 미리 메모리에 함수를 등록하는 작업을 의미한다.
* this란 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값이다.

<br/>

> 함수 선언문

* 함수 선언문은 표현식이 아닌 일반문으로 분류된다.

```javascript
function add(a, b){
    return a + b;
}
```

<br/>

> 함수 표현식

* 함수는 일급 객체이므로 변수에 할당할 수 있다.
* 함수 선언식과 함수 표현식의 가장 큰 차이점은 호이스팅 여부이다.
* 함수 선언식은 호이스팅이 발생하지만 함수 표현식은 호이스팅이 발생하지 않는다.

```javascript
const add = function(a, b) {
    return a + b;
}
```

<br/>

> Function 생성자

* Function 생성자 함수를 사용한 함수 생성은 매개변수와 함수의 몸통을 모두 문자열로 작성해야하기 때문에 코드 작성 관점에서 나쁘다.
* Function 생성자 함수 방식은 함수의 클로저가 생성되지 않는다.

```javascript
const add = new Function('a', 'b', 'return a + b' );
```

<br/>

> 화살표 함수
* ES6에서 새롭게 추가된 함수 생성 방식이다.
* 화살표 함수에서는 constructor를 사용할 수 없다.
* 화살표 함수에서는 argument가 없다.
* 화살표 함수는 함수 자체의 바인딩을 갖지 않아 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따르게 된다.
* 화살표 함수의 this는 선언되는 시점에 결정되며 일반 함수는 함수가 호출되는 런타임 시점에 결정된다.

```javascript
const add = (a, b) => {
    return a + b;
}
```

<br/>

## 1.2.3 함수를 정의하는 4가지 방법

> 즉시 실행 함수

* 함수를 정의하는 즉시 실행되는 함수이다.
* 한 번만 호출되며 이후 다시는 호출할 수 없다.
* 즉시 실행 함수에는 함수명을 붙이지 않는다.
* 즉시 실행 함수의 특성을 통해 글로벌 스코프를 오염시키지 않을 수 있다는 장점이 있다.

```javascript
// 즉시 실행 함수1
(function (a, b) {
    return a + b
})(10, 24);

// 즉시 실행 함수2
((a, b)=> {
    return a + b
})(10, 24);
```

<br/>

> 고차 함수
* 함수가 일급 객체라는 특징을 활용해 함수를 인수로 받거나 반환값으로 함수를 반환시키는 함수이다.
* 함수 컴포넌트를 인수로 받아 새로운 함수 컴포넌트를 반환하는 고차 함수를 만들 수도 있다.
* 고차 함수 컴포넌트를 만들면 컴포넌트 내부에서 공통으로 관리되는 로직을 분리해 관리할 수 있어 효율적인 리팩토링이 가능하다.

```javascript
// 함수를 매개변수로 받는 고차함수 예시(Array.prototype.map)
const doubleArray = [1, 2, 3].map((item)=>item * 2);
```

<br/>

## 1.2.4 함수를 만들 때 주의해야 할 사항

1. 함수의 부수 효과를 억제해야 한다.
2. 함수를 작게 만들어야 한다.
3. 이해할 수 있는 함수명을 붙여야한다.

<br/>
<br/>

# 1.3 클래스
## 1.3.1 클래스란 무엇인가?

* 자바스크립트에서 클래스란 특정한 객체를 만들기 위한 일종의 템플릿이다.
* ES6 이전에는 클래스 개념이 존재하지 않아 클래스 역할을 함수가 대신하였다.

<br/>

> constructor
* constructor는 객체를 생성하는 데 사용하는 특수한 메서드이다.
* constructor는 단 하나만 존재할 수 있다.
* constructor는 생략할 수 있다.

<br/>

> 프로퍼티
* 프로퍼티는 클래스로 인스턴스를 생성할 떄 내부에 정의할 수 있는 속성값을 의미한다.
* 인스턴스를 생성할 때 기본적으로 contructor 내부에 할당되어 있는 빈 객체에 프로터티의 키와 값을 넣어 활용할 수 있도록 한다.

<br/>

> getter
* getter는 클래스에서 어떤 값을 가져올 때 사용된다.
* getter를 사용하기 위해서는 앞에 get을 붙이고 getter의 이름을 선언해야 한다.

<br/>

```js
class Car {
    constructor(name) {
        this.name = name;
    }

    get getMyName() {
        return this.name;
    }
}
```

<br/>

> setter
* getter는 클래스 필드에 어떤 값을 할당할 때 사용된다.
* getter를 사용하기 위해서는 앞에 set을 붙이고 setter의 이름을 선언해야 한다.

<br/>

```js
class Car {
    constructor(name) {
        this.name = name;
    }

    get getMyName() {
        return this.name;
    }

    set setMyName(name) {
        this.name = name;
    }
}
```

<br/>

> 인스턴스 메서드
* 인스턴스 메서드란 클래스 내부에서 선언한 메서드를 의미한다.
* 인스턴스 메서드는 프로토타입에 선언된다.
* 인스턴스 메서드는 프로토타입 메서드라고도 불린다.
* 프로토 타입 체인을 통해 메서드를 생성된 객체(인스턴스)에 직접 선언하지 않았어도 인스턴스 메서드를 호출할 수 있다.

<br/>

> 프로토타입
* 프로토타입이란 다른 객체로부터 속성이나 메서드를 상속받을 수 있게 해주는 메커니즘이다.
* 자바스크립트에서 모든 객체는 prototype이라는 속성을 가지고 있다.

<br/>

> 프로토타입 체인
* 프로토타입 체인이란 객체가 특정 속성이나 메서드를 찾을 때, 해당 객체에 없으면 상위 프로토타입을 계속 따라가면서 찾는 상속 메커니즘이다.
* 프로토타입 체인을 통해 인스턴스가 인스턴스 메서드에 접근할 수 있다.
* Object.getPrototypeOf()를 통해 객체의 프로토타입을 확인할 수 있다.

<br/>

```js
class Person {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

const person1 = new Person('John');
person1.sayHello();  // "Hello, my name is John"

/** 
 * Person은 클래스이다.
 * person1은 Person 클래스의 인스턴스이다.
 * sayHello는 Person 클래스의 프로토타입 메서드로 정의된다.
*/

/** 
 * person1은 Person.prototype을 상속받는다.
 * Person.prototype은 Object.prototype을 상속받는다.
 * Object.prototype은 최상위 부모이다.
*/

```

<br/>

> 정적 메서드
* 정적 메서드란 클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드이다.
* 정적 메서드 내부의 this는 인스턴스가 아닌 클래스 자신을 가리킨다.

<br/>

> 상속
* 상속이란 기존 클래스를 기반으로 확장하는 개념이다.

<br/>

## 1.3.2 클래스와 함수의 관계
* 클래스에서 인스턴스 메서드가 자동으로 프로토타입에 선언되는 것은 함수에서 프로토타입에 함수를 직접 할당하여 구현한다.
* 클래스에서 정적 메서드는 함수에서 메서드를 직접할당하여 구현한다.
* 클래스에서의 getter와 setter는 함수에서 객체에 속성을 직접 정의하여 구현한다.

<br/>
<br/>

# 1.4 클로저

# 1.5 함수

# 1.5 이벤트 루프와 비동기 통신의 이해

# 1.6 리액트에서 자주 사용하는 자바스크립트 문법

# 1.7 선택이 아닌 필수, 타입스크립트
